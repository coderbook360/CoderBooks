# 服务端渲染发展历程

在深入 Vue SSR 源码之前，我们需要先理解一个根本性的问题：服务端渲染是如何一步步演进到今天这个形态的？只有理解了这段历史，我们才能真正明白 Vue SSR 的设计选择背后的逻辑。

## 从最初的 Web 说起

1990 年代初，当 Tim Berners-Lee 发明万维网时，所有网页都是"服务端渲染"的——当然，那时候还没有这个术语。用户请求一个 URL，服务器返回完整的 HTML 文档，浏览器负责显示。这就是 Web 最原始的工作方式。

那个年代的网站是真正的"文档"。每个页面都是独立的 HTML 文件，点击链接意味着加载一个全新的页面。没有 JavaScript 动态交互，没有复杂的前端状态管理，一切都简单直接。

随着 Web 应用变得复杂，开发者开始使用服务端脚本语言来动态生成 HTML。PHP、ASP、JSP 这些技术应运而生。它们的核心思路是一样的：在服务器上执行代码，拼接出 HTML 字符串，然后发送给浏览器。

```php
<?php
// 早期 PHP 动态生成页面的典型模式
$users = fetchUsersFromDatabase();
?>
<html>
<body>
  <h1>用户列表</h1>
  <ul>
    <?php foreach ($users as $user): ?>
      <li><?php echo htmlspecialchars($user['name']); ?></li>
    <?php endforeach; ?>
  </ul>
</body>
</html>
```

这段 PHP 代码展示了服务端渲染的本质：数据和模板在服务器上结合，生成完整的 HTML 发送给客户端。浏览器拿到的是可以直接显示的内容，不需要执行任何 JavaScript 就能看到页面。这种模式简单可靠，搜索引擎也能轻松抓取内容。

这种架构统治了 Web 开发近二十年。Rails、Django、Laravel 等框架都是这一思路的集大成者。它们提供了 MVC 架构、模板引擎、ORM 等工具，让开发者可以高效地构建服务端渲染的应用。

## AJAX 带来的变革

2005 年前后，AJAX 技术开始流行。Gmail 和 Google Maps 向世界展示了无需刷新页面就能更新内容的可能性。这是 Web 发展史上的一个转折点。

AJAX 的出现改变了前端开发者的思维方式。过去，页面交互意味着服务器返回一个新页面。现在，前端可以在后台发起请求，获取数据，然后用 JavaScript 更新页面的局部内容。用户体验得到了显著提升——不再有整页刷新带来的白屏等待。

但 AJAX 只是锦上添花，并没有从根本上改变服务端渲染的主导地位。大多数应用仍然是服务端生成完整页面，只在需要局部更新时才使用 AJAX。

## 单页应用的崛起

真正的变革发生在 2010 年代。随着 Backbone.js、AngularJS、React、Vue 等前端框架的兴起，单页应用（SPA）成为主流。

SPA 的核心理念是把渲染逻辑从服务器移到客户端。服务器只需要返回一个几乎空白的 HTML 外壳和一堆 JavaScript 文件，浏览器执行这些 JavaScript，动态生成页面内容。

```html
<!-- 典型的 SPA 入口 HTML -->
<!DOCTYPE html>
<html>
<head>
  <title>My SPA App</title>
</head>
<body>
  <div id="app"></div>
  <script src="/js/vendor.js"></script>
  <script src="/js/app.js"></script>
</body>
</html>
```

这个 HTML 文件几乎没有内容，只有一个空的 `<div id="app">`。所有的页面结构、数据获取、交互逻辑都由 JavaScript 在浏览器中完成。这就是所谓的客户端渲染（CSR）。

SPA 带来了革命性的用户体验。页面切换瞬间完成，无需等待服务器响应。复杂的交互逻辑可以用优雅的组件化方式实现。前后端可以完全分离，各自独立开发和部署。

但 SPA 也带来了新的问题。首先是首屏加载变慢了。用户访问页面时，浏览器需要先下载 JavaScript 文件，然后执行它们，再发起数据请求，最后才能渲染出内容。这个过程可能需要好几秒，用户看到的是空白页面或加载动画。其次是 SEO 问题。搜索引擎爬虫访问页面时，看到的只是那个空白的 HTML 外壳，无法索引动态生成的内容。

## SSR 的回归

当 SPA 的问题变得越来越明显时，开发者开始思考：能不能既保留 SPA 的优秀交互体验，又解决首屏性能和 SEO 问题？

答案是回到服务端渲染——但不是回到 PHP/JSP 那种纯服务端渲染，而是一种新的架构：同构渲染。

同构渲染的核心思路是让同一套代码能够同时在服务器和浏览器中运行。当用户首次访问页面时，服务器执行前端框架的渲染逻辑，生成完整的 HTML 发送给浏览器。用户立即看到完整的页面内容，不需要等待 JavaScript 加载和执行。然后，浏览器加载 JavaScript 代码，"接管"这个已经渲染好的页面，后续的交互就完全在客户端完成，享受 SPA 的流畅体验。

这个从服务端渲染到客户端接管的过程有一个专门的术语：水合（Hydration）。我们会在后续章节详细讨论这个概念。

2016 年，Vue 2.0 发布，内置了服务端渲染支持。同年，基于 Vue 的同构框架 Nuxt.js 问世，大大降低了 Vue SSR 的使用门槛。React 阵营也有类似的发展，Next.js 于 2016 年发布。这些框架的出现标志着同构渲染从理论走向了工程实践。

## 技术演进的脉络

回顾这段历史，我们可以看到一个清晰的演进脉络：

第一阶段是纯服务端渲染时期。服务器负责所有的渲染工作，浏览器只是被动地显示 HTML。这种模式简单可靠，但用户体验受限于每次操作都需要刷新页面。

第二阶段是客户端渲染的兴起。JavaScript 接管了渲染职责，带来了流畅的交互体验，但也带来了首屏性能和 SEO 问题。

第三阶段是同构渲染的成熟。开发者意识到服务端渲染和客户端渲染不是非此即彼的选择，而是可以结合使用的技术。通过同构渲染，我们可以同时获得两种方案的优势。

这个演进过程也反映了工程实践中的一个普遍规律：技术发展往往不是线性进步，而是螺旋式上升。我们似乎"回到"了服务端渲染，但这个"回归"是在更高层次上的整合，融合了客户端渲染时代积累的所有经验和工具。

## Vue SSR 的定位

Vue 的 SSR 实现正是在这个背景下诞生的。它需要解决几个核心问题：如何让 Vue 组件的渲染逻辑在服务器上执行，生成 HTML 字符串？如何确保服务端渲染的 HTML 和客户端渲染的结果一致，从而实现无缝的水合？如何处理服务端环境和浏览器环境的差异？

在接下来的章节中，我们会逐一回答这些问题。我们会从 Vue SSR 的设计目标开始，理解它的架构思路，然后深入源码，看看这些设计是如何实现的。最后，我们会动手实现一个简化版的 SSR 方案，通过实践加深对这些概念的理解。

理解了 SSR 的发展历程，我们就能更好地理解 Vue SSR 为什么是现在这个样子。它不是凭空设计出来的，而是对 Web 开发二十多年实践经验的总结和提炼。
