# 水合（Hydration）概念

在前面的章节中，我们多次提到"水合"这个术语。现在是时候深入理解这个同构渲染中最核心的概念了。

## 什么是水合

水合（Hydration）这个词来源于化学领域，指的是水分子与其他物质结合的过程。在前端语境中，它描述的是一个类似的"激活"过程：服务端渲染的静态 HTML 与客户端 JavaScript 结合，变成一个可交互的应用。

想象一下服务端渲染的 HTML 就像是一个干燥的海绵——它有形状、有结构，但缺乏活力。JavaScript 就像水一样"注入"到这个结构中，让它变得有弹性、可响应。这就是"水合"这个比喻的来源。

从技术层面来说，水合是这样一个过程：客户端的 JavaScript 代码检查已经存在的 DOM 结构，将其与虚拟 DOM 进行匹配，在 DOM 节点上附加事件监听器和响应式绑定，最终使页面变得可交互。

## 水合的工作流程

让我们通过一个具体的例子来理解水合的过程。假设有这样一个 Vue 组件：

```javascript
// Counter.vue
export default {
  data() {
    return { count: 0 }
  },
  template: `
    <div class="counter">
      <span>{{ count }}</span>
      <button @click="count++">+1</button>
    </div>
  `
}
```

当这个组件在服务端渲染时，Vue 会生成对应的 HTML 字符串。假设初始 count 为 0，生成的 HTML 可能是这样：

```html
<div class="counter" data-v-app>
  <span>0</span>
  <button>+1</button>
</div>
```

这个 HTML 发送到浏览器后，用户可以立即看到内容。但此时按钮是"死的"——点击它不会有任何反应，因为事件监听器还没有附加上去。

接下来客户端 JavaScript 加载并执行。Vue 应用创建虚拟 DOM 树，描述组件应该渲染成什么样子。然后 Vue 进入水合模式：它遍历已存在的 DOM，与虚拟 DOM 进行对比，确认两者匹配后，在对应的 DOM 节点上附加事件监听器和响应式绑定。

水合完成后，按钮就"活"了。点击按钮会触发 `count++`，响应式系统会追踪这个变化，触发重渲染，span 中的数字会更新。

## 水合与重新渲染的区别

理解水合，关键是要区分它与普通客户端渲染的区别。

在纯客户端渲染（CSR）模式下，`app.mount('#app')` 会查看目标容器，发现里面是空的或者只有占位符，于是从头开始创建 DOM 节点，插入到容器中。

在水合模式下，`app.mount('#app')` 发现容器里已经有了服务端渲染的 DOM 结构。Vue 不会销毁这些 DOM 然后重建，而是"复用"它们——遍历现有 DOM，与虚拟 DOM 对比，确认匹配后直接附加事件和响应式绑定。

这个复用过程是水合能够提升性能的关键。如果客户端销毁服务端的 HTML 然后重新渲染，用户会看到页面闪烁（内容消失后再出现），而且失去了 SSR 的性能优势。水合确保了平滑的过渡——服务端渲染的内容始终可见，只是在背后悄悄变得可交互。

```javascript
// Vue 3 中的水合是自动的
import { createSSRApp } from 'vue'
import App from './App.vue'

const app = createSSRApp(App)

// 当 mount 时，如果 DOM 已存在内容，Vue 会自动进入水合模式
app.mount('#app')
```

使用 `createSSRApp` 创建的应用在挂载时会自动检测是否需要水合。如果目标容器中已有服务端渲染的内容，Vue 会进入水合模式；如果容器为空，则进行普通的客户端渲染。

## 水合的核心挑战

水合过程看起来简单，但实际实现中有几个核心挑战需要解决。

第一个挑战是 DOM 匹配。客户端创建的虚拟 DOM 必须与服务端渲染的真实 DOM 精确匹配。每个元素的标签名、属性、子节点结构都必须一致。如果有任何不匹配，水合就会出问题。

第二个挑战是状态同步。服务端渲染时使用的数据必须传递给客户端，否则客户端会用不同的数据渲染出不同的结构。这就是为什么 SSR 框架都会将初始状态序列化到 HTML 中。

```html
<!-- 服务端返回的 HTML 中包含序列化的状态 -->
<script>
  window.__INITIAL_STATE__ = {"user":{"name":"Alice"},"posts":[...]}
</script>
```

客户端应用在初始化时读取这个状态，确保使用与服务端相同的数据进行水合。

第三个挑战是事件绑定的时机。水合过程需要遍历整个 DOM 树，在正确的节点上附加事件监听器。在大型应用中，这个过程可能需要一些时间。在水合完成之前，用户的交互操作不会得到响应。

## 水合的性能考量

水合并不是免费的。虽然 SSR 提升了首屏内容出现的速度（FCP），但页面真正可交互的时间（TTI）并不会因此提前——客户端仍然需要加载 JavaScript、执行代码、完成水合过程。

事实上，SSR+水合的组合在某些指标上可能比纯 CSR 更慢。CSR 在 JavaScript 执行完成后页面立即可交互，而 SSR 在 JavaScript 执行完成后还需要进行水合。虽然水合比重新渲染快，但仍然需要时间。

这就引出了一个关键洞察：SSR 优化的主要是"感知性能"而非"绝对性能"。用户更早看到内容，心理上的等待时间缩短了，即使页面真正可交互的时间并没有提前。

对于大型应用，水合可能成为性能瓶颈。一个包含数百个组件的页面，水合过程需要遍历所有组件，附加所有事件监听器，这可能需要数百毫秒甚至更长时间。在这段时间内，页面看起来已经加载完成，但用户的点击操作没有响应，这会造成很差的用户体验。

为了解决这个问题，社区发展出了多种优化策略：渐进式水合、选择性水合、部分水合等。这些策略的核心思想都是减少首次水合需要处理的工作量。我们会在后续章节详细讨论这些策略。

## 水合的代价

水合模式要求客户端下载并执行足够的 JavaScript 来重建整个应用的组件树。这意味着：即使页面的某些部分永远不会有交互（比如文章的正文内容），客户端仍然需要加载渲染这些部分所需的组件代码。

这个问题在以内容为主的网站上尤为明显。一篇博客文章可能只有导航栏和评论区需要交互，但水合过程仍然需要处理整个页面的所有组件。

```javascript
// 整个页面都需要水合，即使大部分内容是静态的
<template>
  <div>
    <Navbar />           <!-- 需要交互 -->
    <article>            <!-- 纯静态内容 -->
      {{ content }}      
    </article>
    <CommentSection />   <!-- 需要交互 -->
  </div>
</template>
```

针对这个问题，一些框架开始探索"岛屿架构"（Islands Architecture）。在这种架构中，页面被分割为多个独立的"岛屿"，只有需要交互的岛屿才会被水合，静态内容保持为纯 HTML。Astro 是这种架构的代表性框架。

## Vue 的水合机制

Vue 3 的水合实现在 `@vue/runtime-core` 包中。当检测到需要水合时，Vue 会使用一个专门的 `hydrate` 函数而不是普通的 `mount` 函数。

水合过程从根节点开始，递归遍历组件树。对于每个组件，Vue 会：

1. 找到对应的 DOM 节点
2. 比较虚拟 DOM 和真实 DOM 的结构
3. 如果匹配，复用 DOM 节点，附加事件监听器
4. 如果不匹配，发出警告（开发模式）或尝试恢复

```javascript
// 简化的水合流程伪代码
function hydrate(vnode, container) {
  const el = container.firstChild
  
  if (vnode.type === 'div' && el.tagName === 'DIV') {
    // 匹配成功，复用 DOM 节点
    vnode.el = el
    
    // 附加事件监听器
    if (vnode.props?.onClick) {
      el.addEventListener('click', vnode.props.onClick)
    }
    
    // 递归处理子节点
    hydrateChildren(vnode.children, el)
  } else {
    // 不匹配，报错或恢复
    console.warn('Hydration mismatch')
  }
}
```

在后续的源码解析章节中，我们会详细阅读 Vue 水合的完整实现。

## 总结

水合是同构渲染的核心机制，它让服务端渲染的静态 HTML"活"过来。理解水合的工作原理、挑战和代价，有助于我们做出正确的架构决策，避免常见的性能陷阱。

在下一章中，我们会讨论水合过程中最常见的问题：水合不匹配。理解什么情况会导致不匹配、如何诊断和修复这些问题，是使用 SSR 的必备技能。
