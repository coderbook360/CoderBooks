# Vue3 的核心设计理念

Vue3 的设计并非凭空产生，而是建立在一系列清晰的设计原则之上。理解这些原则，能帮助我们更好地把握 Vue3 各个模块的设计逻辑。

## 渐进式框架的坚持

Vue 一直以"渐进式框架"著称，Vue3 延续并强化了这一理念。渐进式意味着开发者可以根据项目需求，选择使用 Vue 的一部分功能，而不必接受整个技术栈。

在最简单的场景下，Vue3 可以像 jQuery 一样通过 CDN 引入，直接在 HTML 中使用。随着项目复杂度增加，可以逐步引入单文件组件、路由、状态管理等能力。这种灵活性降低了学习曲线和迁移成本。

```html
<!-- 最简单的 Vue3 使用方式 -->
<script src="https://unpkg.com/vue@3"></script>
<div id="app">{{ message }}</div>
<script>
  Vue.createApp({
    data() { return { message: 'Hello Vue3' } }
  }).mount('#app')
</script>
```

从架构层面，渐进式体现在模块解耦上。`@vue/reactivity` 可以独立使用，不依赖 DOM 渲染；`@vue/runtime-core` 可以搭配自定义渲染器用于非 DOM 环境；各个功能模块可以按需引入，支持 Tree-shaking。

## 声明式优于命令式

Vue 始终推崇声明式编程风格。开发者描述"界面应该是什么样子"，而不是"如何操作 DOM 达到这个效果"。这种抽象带来了更高的开发效率和更少的出错可能。

声明式编程的核心是建立数据与视图的映射关系。当数据变化时，框架自动计算出需要的 DOM 操作并执行。开发者不需要手动追踪状态变化，也不需要编写繁琐的 DOM 操作代码。

```javascript
// 声明式：描述最终状态
const count = ref(0)
// 模板中：<button @click="count++">{{ count }}</button>

// 命令式：描述操作步骤
let count = 0
button.addEventListener('click', () => {
  count++
  button.textContent = count  // 手动更新 DOM
})
```

Vue3 的响应式系统和虚拟 DOM 共同支撑了声明式编程范式。响应式系统追踪依赖关系，虚拟 DOM 计算最小更新操作，二者协作让声明式代码获得接近手写命令式代码的性能。

## 约定优于配置

Vue 通过合理的默认行为减少必要的配置。Props 默认是只读的，Emits 默认验证事件名称，单文件组件默认开启 scoped CSS。这些约定覆盖了大多数场景的最佳实践。

当默认行为不能满足需求时，Vue 提供了明确的配置选项。但配置是可选的，不强制要求。这种设计让简单场景保持简单，复杂场景依然可控。

## 编译时与运行时的平衡

Vue3 在编译时和运行时之间寻找平衡点。模板在编译阶段被分析和优化，生成高效的渲染函数；运行时则专注于执行渲染和响应更新。

编译时优化包括静态节点提升、动态节点标记、事件处理器缓存等。这些优化对开发者透明，不需要额外配置就能享受性能提升。

```javascript
// 模板
<div>
  <span>静态文本</span>
  <span>{{ dynamic }}</span>
</div>

// 编译后（简化）
const _hoisted = createVNode('span', null, '静态文本')  // 静态提升

function render() {
  return createVNode('div', null, [
    _hoisted,  // 复用静态节点
    createVNode('span', null, ctx.dynamic, 1 /* TEXT */)  // 标记动态部分
  ])
}
```

这种平衡让 Vue 既保持了开发时的灵活性（可以使用模板或 JSX），又获得了生产环境的高性能。Svelte 走向了更激进的编译时优化，React 则更依赖运行时。Vue 选择了中间路线，在两者之间取得平衡。

## 可预测性与可调试性

Vue3 强调代码行为的可预测性。响应式更新是同步触发、异步批量执行的，这个时机是确定的；组件更新遵循单向数据流，父组件更新可能触发子组件更新，但反过来不会。

可调试性体现在错误信息的质量、开发者工具的完善、以及源码的可读性上。Vue3 提供了详细的警告信息帮助定位问题，Vue Devtools 支持组件树检查、状态追踪、性能分析等功能。

这些设计原则贯穿于 Vue3 的各个模块，在后续章节中，我们会看到它们如何具体落地。
