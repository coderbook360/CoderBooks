# 编译时 vs 运行时

Vue 提供了两种编译模式：编译时（构建时）编译和运行时编译。理解两者的区别和适用场景，对于优化应用性能和选择正确的 Vue 构建版本至关重要。

## 两种编译模式

编译时编译发生在项目构建阶段。Vite、Webpack 等构建工具在打包过程中调用 Vue 编译器，将模板转换成渲染函数。最终打包产物中不包含模板字符串，只有编译后的 JavaScript 代码。

运行时编译发生在浏览器中。当应用启动时，Vue 读取组件的 template 选项，调用内置编译器将其转换为渲染函数。这需要将编译器代码一起打包到应用中。

## 构建产物的差异

Vue 提供多个构建版本来支持不同场景。

仅运行时版本（vue.runtime.esm-bundler.js）体积约 20KB gzipped，不包含模板编译器。使用这个版本时，所有模板必须在构建时预编译。

完整版（vue.esm-bundler.js）体积约 30KB gzipped，包含模板编译器。可以在运行时编译 template 选项。

这 10KB 的差异在生产环境中很有意义。如果应用所有模板都预编译了，就没必要把编译器代码发送给用户。

## 为什么需要运行时编译

虽然预编译是更优的选择，但某些场景确实需要运行时编译。

动态模板是最常见的场景。模板内容可能来自后端 API、用户输入或 CMS 系统，在构建时无法确定。这时只能在运行时编译。

另一个场景是快速原型开发。不想配置构建工具，直接在 HTML 中写 Vue 组件。虽然不适合生产环境，但对于学习和实验很方便。

还有一些传统项目渐进式引入 Vue 的场景。现有页面通过 script 标签引入 Vue，在特定区域使用 Vue 组件，不想引入完整的构建流程。

## 性能对比

预编译有显著的性能优势。

首先是加载性能。编译器代码不需要加载，节省了约 10KB（压缩后）的传输体积。对于移动端和弱网环境，这个差异更加明显。

其次是初始化性能。运行时编译需要在应用启动时编译模板，这会增加首次渲染的时间。编译本身需要 CPU 时间，大型模板的编译可能需要几十毫秒。

预编译还能实现更多优化。构建时可以做静态提升、常量折叠等优化，这些在运行时编译中可能因为性能考虑而被跳过。

## 编译缓存

运行时编译的性能问题可以通过缓存部分缓解。Vue 会缓存编译结果，相同的模板字符串只编译一次。

```javascript
const cache = Object.create(null)

function compileToFunction(template) {
  const key = template
  const cached = cache[key]
  if (cached) {
    return cached
  }
  
  const { code } = compile(template)
  const render = new Function('Vue', code)(runtimeDom)
  
  return (cache[key] = render)
}
```

但缓存只在同一个页面会话中有效。页面刷新后，所有模板需要重新编译。

## 构建工具集成

现代 Vue 项目通常使用 Vite 或 Webpack，它们通过插件集成 Vue 编译器。

Vite 使用 @vitejs/plugin-vue，Webpack 使用 vue-loader。这些工具在处理 .vue 文件时，会提取 template 块调用 Vue 编译器，将结果作为 render 函数注入组件。

构建工具还处理热更新（HMR）。当模板修改时，只重新编译变化的组件，更新浏览器中的渲染函数，而不需要刷新整个页面。

## 模板 vs 渲染函数

预编译的本质是将声明式的模板转换为命令式的渲染函数。开发者也可以直接写渲染函数，跳过模板：

```javascript
export default {
  render() {
    return h('div', { class: 'container' }, [
      h('span', this.message)
    ])
  }
}
```

直接写渲染函数不需要编译，运行时和完整版行为相同。但失去了模板的声明式优势和编译时优化。

一个折中方案是使用 JSX。JSX 在构建时由 Babel 转换，不依赖 Vue 编译器，产物类似手写渲染函数。

## 调试体验

运行时编译的调试体验较差。生成的渲染函数是 eval 产生的动态代码，没有 source map 支持，调试时看到的是编译后的代码。

预编译可以生成 source map，让调试器显示原始模板。这需要构建工具正确配置 source map 生成。

Vue DevTools 对两种模式都有支持，但预编译时能提供更准确的组件信息。

## 错误处理

编译错误在两种模式下表现不同。

预编译时，模板错误在构建阶段暴露。构建失败，开发者看到编译错误信息。这是更好的体验——问题在开发时就被发现，不会到达用户。

运行时编译的错误在应用运行时发生。如果模板有语法错误，可能导致组件挂载失败。虽然 Vue 会捕获并报告这些错误，但问题已经影响了用户体验。

## 如何选择

绝大多数生产应用应该使用预编译。配置现代构建工具并不复杂，性能收益和开发体验都值得这个投入。

运行时编译保留给确实需要的场景：真正的动态模板、传统项目集成、快速原型。即使这些场景，也应该考虑是否有预编译的替代方案。

如果使用 CDN 直接引入 Vue，可以选择 vue.global.prod.js（完整版）或 vue.runtime.global.prod.js（仅运行时版）。如果所有组件都使用 render 函数或预编译模板，选择仅运行时版本可以减小体积。

## 小结

编译时和运行时编译的核心权衡是：包含编译器的灵活性与不包含编译器的性能。Vue 通过提供不同的构建版本，让开发者根据具体需求做出选择。对于构建工具驱动的现代项目，预编译是默认且推荐的方式；运行时编译则为特殊场景保留了可能性。
