# 设计权衡与取舍

编译器的每个设计决策都涉及权衡。性能与简洁性、灵活性与安全性、编译时与运行时——这些维度相互制约。理解这些权衡有助于理解 Vue 编译器为什么这样设计，也有助于在遇到边缘情况时做出正确判断。

## 编译时 vs 运行时

Vue 在编译时和运行时之间寻找平衡点。

更多编译时工作意味着：生成的代码更大、编译更慢、但运行更快。更多运行时工作意味着：编译快、代码小、但运行慢。

Vue 3 的选择是偏向编译时。静态提升、Patch Flags、Block Tree 都增加了编译输出的大小，但换来了显著的运行时性能提升。

这个选择基于几个判断：编译通常只发生一次（构建时），运行发生无数次；现代设备的网络带宽增长快于 CPU 速度；开发体验可以通过工具弥补。

## 优化激进程度

优化可以很激进，但激进的优化可能引入边缘问题。

例如静态节点的处理。Vue 3 将大块静态内容序列化为 HTML 字符串，首次挂载时 innerHTML。这很快，但如果静态内容中有脚本（虽然不应该有），可能有安全问题。

Vue 选择相对保守的策略：在确定安全的情况下才应用激进优化。当无法确定时（如动态参数、未知指令），退回到完整的运行时处理。

BAIL 标记（-2）就是这种保守策略的体现——放弃优化，确保正确性。

## 向后兼容性

Vue 3 需要兼容大部分 Vue 2 的模板语法。这限制了某些更优设计的采用。

例如，v-if 和 v-for 的优先级。Vue 2 中 v-for 优先级更高，Vue 3 改为 v-if 更高。这是破坏性变更，需要迁移工具支持。

更激进的语法改进（如使用 JSX 式的控制流组件）被放弃，因为迁移成本太高。编译器需要处理各种历史遗留的语法变体。

## 错误信息质量 vs 编译速度

精确的错误信息需要保留更多上下文，可能影响编译速度。

Vue 编译器选择在开发环境提供详细错误信息（位置、上下文、建议），生产环境简化处理。这通过条件编译实现：

```javascript
if (__DEV__) {
  warn(`Missing required prop: "${key}"`, instance)
}
```

开发环境的编译稍慢但体验更好，生产环境编译更快且代码更小。

## Source Map 的开销

精确的 Source Map 需要编译全程追踪位置信息，有性能开销。

每创建一个 AST 节点、每做一次转换、每输出一个字符，都要记录位置映射。这些信息增加了内存使用和处理时间。

Vue 允许通过配置关闭 Source Map 生成，在不需要调试时获得更快的编译速度。但默认是开启的，因为调试体验非常重要。

## 模块化 vs 包体积

Tree-shakable 设计意味着更多的模块划分，可能增加模块加载开销。

如果拆分太细，可能有大量小文件，增加 HTTP 请求（HTTP/1.1 时代的问题）和模块解析开销。如果拆分太粗，Tree Shaking 效果降低。

Vue 选择按功能拆分：响应式、运行时核心、编译器、各种指令和组件分开。这在 Tree Shaking 效果和模块管理复杂度之间取得平衡。

## 指令语法的表达力

Vue 的指令语法（v-if、v-for、v-bind）是 DSL，表达力有限。

与 JSX 相比，某些复杂逻辑在模板中难以表达。但这种限制也是优势——它让静态分析成为可能，让模板更可预测。

Vue 选择保持模板语法的约束，同时提供 JSX 作为逃生舱口。对于需要完全表达力的场景，可以使用 render 函数或 JSX。

## 类型推导的复杂度

script setup 的类型推导需要编译器理解 TypeScript。

这增加了编译器复杂度，也可能有边缘情况的类型推导不准确。完全正确地理解 TypeScript 类型系统几乎不可能——TypeScript 本身的类型系统图灵完备。

Vue 选择支持常见模式，对于复杂的类型场景可能需要显式标注。Volar 等工具不断改进，逐步覆盖更多场景。

## 插件系统的灵活性

编译器转换阶段是插件化的，允许自定义转换。

但过于灵活的插件系统可能导致不可预测的行为、插件间冲突、调试困难。

Vue 选择中等程度的灵活性：提供节点转换钩子，但核心转换顺序固定。这让常见的自定义需求可以满足，同时保持编译行为的可预测性。

## 运行时编译的保留

支持运行时编译增加了打包体积（如果使用完整版），也有安全风险（编译用户输入可能导致 XSS）。

Vue 选择保留运行时编译能力，但默认推荐预编译。运行时编译对于某些场景（如 CMS 动态模板）确实有用，完全移除会限制这些用例。

安全责任交给开发者——如果编译用户输入，必须确保内容可信。

## 小结

编译器设计是一系列权衡的结果。Vue 3 编译器的选择反映了其优先级：运行时性能 > 编译时性能、开发体验 > 极致优化、正确性 > 激进优化、向后兼容 > 完美设计。理解这些权衡有助于在特定场景下做出合适的选择，也有助于在遇到编译器限制时理解其原因。没有完美的设计，只有适合特定需求的设计。
